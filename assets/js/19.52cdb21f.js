(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{229:function(e,n,t){"use strict";t.r(n);var r=t(1),a=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"准备工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#准备工作"}},[e._v("#")]),e._v(" 准备工作")]),e._v(" "),t("h3",{attrs:{id:"flow"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#flow"}},[e._v("#")]),e._v(" flow")]),e._v(" "),t("p",[e._v("facebook出品的JavaScript静态类型检查工具。")]),e._v(" "),t("p",[e._v("JavaScript是动态语言，过于灵活会导致由类型错误引起的bug。")]),e._v(" "),t("p",[e._v("类型检查是在编译期尽早发现类型错误bug，又不影响代码运行。")]),e._v(" "),t("p",[e._v("Babel和ESlint都有对应Flow插件，小成本改动即可拥有静态类型检查能力。")]),e._v(" "),t("h4",{attrs:{id:"flow的工作方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#flow的工作方式"}},[e._v("#")]),e._v(" flow的工作方式")]),e._v(" "),t("ul",[t("li",[e._v("类型推断: 通过变量的使用上下文来推断出变量类型并检查。")]),e._v(" "),t("li",[e._v("类型注释: 事先注释好期待的类型。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function split(str) {\n  return str.split(' ')\n}\nsplit(11); // Error: str must be string\n\nfunction add (x, y) {\n  return x + y;\n}\nadd('Hello', 11); // No error\n\nfunction add (x: number, y: number): number {\n  return x + y;\n}\nadd('Hello', 11); // Error: arguments must be number\n\nvar arr: Array<number> = [1, 2, 3]\narr.push('hello') // Error: items must be number\n\nclass Bar {\n  x: string;\n  y: string | number;\n}\n\nvar obj: {\n  a: string,\n  b: number,\n  c: Array<string>,\n  d: Bar\n} = {\n  a: 'hello',\n  b: 11,\n  c: ['hello', 'world'],\n  d: new Bar('hello', 3)\n}\n")])])]),t("h4",{attrs:{id:"vue源码中的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue源码中的应用"}},[e._v("#")]),e._v(" vue源码中的应用")]),e._v(" "),t("p",[e._v("配置文件为根目录的.flowconfig，库定义目录为"),t("code",[e._v("flow")])]),e._v(" "),t("h3",{attrs:{id:"源码目录设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码目录设计"}},[e._v("#")]),e._v(" 源码目录设计")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("src\n├── compiler        # 编译相关 \n├── core            # 核心代码 \n├── platforms       # 不同平台的支持\n├── server          # 服务端渲染\n├── sfc             # .vue 文件解析\n├── shared          # 共享代码\n")])])]),t("h4",{attrs:{id:"compiler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#compiler"}},[e._v("#")]),e._v(" compiler")]),e._v(" "),t("p",[e._v("所有编译相关代码，将模板解析为ast语法树，优化，生成代码。\n编译可以在构建时做(webpack and vue-loader)也可以在运行时做(runtime with compiler)。\n编译是一项耗性能的工作，推荐离线编译。")]),e._v(" "),t("h4",{attrs:{id:"core"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#core"}},[e._v("#")]),e._v(" core")]),e._v(" "),t("p",[e._v("core包含了Vue.js的核心代码，包括内置组件，全局API封装，Vue实例化，观察者，虚拟DOM，工具函数。")]),e._v(" "),t("h4",{attrs:{id:"platform"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#platform"}},[e._v("#")]),e._v(" platform")]),e._v(" "),t("p",[e._v("Vue.js 是跨平台的MVVM框架，可以跑在web上，也可以配合weex跑在native客户端上。\n这里是不同平台的入口文件。")]),e._v(" "),t("h4",{attrs:{id:"server"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#server"}},[e._v("#")]),e._v(" server")]),e._v(" "),t("p",[e._v("Vue.js 2.0支持了服务器渲染，所有服务端渲染相关逻辑都在这个目录。这里是跑在服务器的Node.js代码。")]),e._v(" "),t("h4",{attrs:{id:"sfc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sfc"}},[e._v("#")]),e._v(" sfc")]),e._v(" "),t("p",[e._v("将.vue文件内容解析为一个JavaScript对象。")]),e._v(" "),t("h4",{attrs:{id:"shared"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#shared"}},[e._v("#")]),e._v(" shared")]),e._v(" "),t("p",[e._v("可以共用的工具方法。")]),e._v(" "),t("h3",{attrs:{id:"vue-js源码构建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-js源码构建"}},[e._v("#")]),e._v(" Vue.js源码构建")]),e._v(" "),t("p",[t("code",[e._v("scripts/build.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let builds = require('./config').getAllBuilds()\nif (process.argv[2]) {\n  const filters = process.argv[2].split(',')\n  builds = builds.filter(b => {\n    return filters.some(f => b.output.file.indexOf(f) > -1 || b._name.indexOf(f) > -1)\n  })\n}\n")])])]),t("p",[t("code",[e._v("scripts/config.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const aliases = require('./alias')\nconst resolve = p => {\n  const base = p.split('/')[0]\n  if (aliases[base]) {\n    return path.resolve(aliases[base], p.slice(base.length + 1))\n  } else {\n    return path.resolve(__dirname, '../', p)\n  }\n}\nfunction genConfig (name) {\n  const opts = builds[name]\n  const config = {\n    input: opts.entry,\n    external: opts.external,\n    plugins: [\n      flow(),\n      alias(Object.assign({}, aliases, opts.alias))\n    ].concat(opts.plugins || []),\n    output: {\n      file: opts.dest,\n      format: opts.format,\n      banner: opts.banner,\n      name: opts.moduleName || 'Vue'\n    },\n    onwarn: (msg, warn) => {\n      if (!/Circular/.test(msg)) {\n        warn(msg)\n      }\n    }\n  }\n  ...\n  return config\n}\n\nconst builds = {\n  // Runtime only (CommonJS). Used by bundlers e.g. Webpack & Browserify\n  'web-runtime-cjs': {\n    entry: resolve('web/entry-runtime.js'),\n    dest: resolve('dist/vue.runtime.common.js'),\n    format: 'cjs',\n    banner\n  },\n  // Runtime+compiler CommonJS build (CommonJS)\n  'web-full-cjs': {\n    entry: resolve('web/entry-runtime-with-compiler.js'),\n    dest: resolve('dist/vue.common.js'),\n    format: 'cjs',\n    alias: { he: './entity-decoder' },\n    banner\n  },\n  ...\n}\n\nexports.getAllBuilds = () => Object.keys(builds).map(genConfig)\n")])])]),t("ul",[t("li",[e._v("Runtime + Compiler\n在 Vue.js 2.0 中，最终渲染都是通过 render 函数，如果写 template 属性，则需要编译成 render 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本。")])]),e._v(" "),t("h3",{attrs:{id:"入口文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#入口文件"}},[e._v("#")]),e._v(" 入口文件")]),e._v(" "),t("p",[t("code",[e._v("src/core/instance/index.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n")])])]),t("p",[e._v("Vue是一个用Function实现的类，只能通过new Vue去实例化它。\nVue的功能都是在Vue.prototype上扩展的方法，按功能分散在多个模块，这是class写法难以实现的，便于代码的维护和管理。")]),e._v(" "),t("h2",{attrs:{id:"数据驱动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据驱动"}},[e._v("#")]),e._v(" 数据驱动")]),e._v(" "),t("p",[e._v("指视图由数据驱动，对视图的修改不会直接操作DOM，而是通过修改数据，使得用户的代码量大大简化。DOM变成了数据的映射，所有的逻辑都是对数据的修改而不用触碰DOM，这样的代码非常利于维护。")]),e._v(" "),t("h3",{attrs:{id:"new-vue-发生了什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new-vue-发生了什么"}},[e._v("#")]),e._v(" new Vue 发生了什么")]),e._v(" "),t("p",[e._v("构造函数中限制Vue只能通过new关键字初始化，之后调用this._init方法。")]),e._v(" "),t("p",[t("code",[e._v("src/core/instance/init.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.prototype._init = function (options?: Object) {\n  const vm: Component = this;\n  vm._uid = uid++\n  ...\n  // 合并配置\n  if (options && options._isComponent) {\n    initInternalComponent(vm, options)\n  }\n  else {\n    vm.$options = mergeOptions(\n      resolveConstructorOptions(vm.constructor),\n      options || {},\n      vm\n    )\n  }\n  vm._self = vm\n  initLifecycle(vm) // 初始化生命周期\n  initEvents(vm) // 初始化事件中心\n  initRender(vm) // 初始化渲染\n  callHook(vm, 'beforeCreate') // 触发生命周期钩子\n  initInjections(vm) // resolve injections before data/props\n  initState(vm) // 初始化 data/props\n  initProvide(vm) // resolve provide after data/props\n  callHook(vm, 'created') // 触发生命周期钩子\n  if (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n  }\n}\n")])])]),t("p",[e._v("检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM。")]),e._v(" "),t("h3",{attrs:{id:"vue实例挂载的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue实例挂载的实现"}},[e._v("#")]),e._v(" Vue实例挂载的实现")]),e._v(" "),t("p",[t("code",[e._v("src/platform/web/entry-runtime-with-compiler.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.prototype.$mount = function ( ...\nif (el === document.body || el === document.documentElement) warn()\nif (!options.render) {\n  if (template.charAt(0) === '#') template = idToTemplate(template)\n  else if (template.nodeType) template = template.innerHTML\n  else if (el) template = getOuterHTML(el)\n  if (template) {\n    const { render, staticRenderFns } = compileToFunctions(template)\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n  }\n  return mount.call(this, el, hydrating)\n}\n")])])]),t("p",[e._v("其中的代码定义，Vue 不能挂载在 html 或者 body 之类的根节点。如果没有定义 render 函数，则会将 el 或者 template 字符串转化为 render 方法。\n原型上的 $mount 在 "),t("code",[e._v("src/platform/web/runtime/index.js")]),e._v(" 上定义，可以直接被 runtime only 版本的 Vue 直接使用。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.prototype.$mount = function(\n  el?: string | Element, // 挂载的元素，可以是字符串，也可以是DOM对象。\n  hydrating?: boolean // 服务器渲染相关参数\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  return mountComponent(this, el, hydrating);\n}\n")])])]),t("p",[t("code",[e._v("src/core/instance/lifecycle.js")]),e._v(" 中定义了 "),t("code",[e._v("mountComponent")]),e._v(" 方法。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vm.$el = el\nif (!vm.$options.render) {\n  vm.$options.render = createEmptyVNode\n  if ((vm.$options.template) || vm.$options.el || el) warn('You are using the runtime-only build of Vue');\n  else warn('template or render function not defined.')\n}\ncallHook(vm, 'beforeMount')\nlet updateComponent\nupdateComponent = () => {\n  vm._update(vm._render(), hydrating)\n}\nnew Watcher(vm, updateComponent, noop, {\n  before () {\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate')  // 触发生命周期钩子\n    }\n  }\n}, true /* isRenderWatcher */)\nhydrating = false\nif (vm.$vnode == null) {\n  vm._isMounted = true\n  callHook(vm, 'mounted')  // 触发生命周期钩子\n}\nreturn vm\n")])])]),t("p",[e._v("Watcher 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数。")]),e._v(" "),t("p",[e._v("vm.$vnode 表示 Vue 实例的父虚拟 Node，所以它为 Null 则表示当前是根 Vue 的实例。")]),e._v(" "),t("h3",{attrs:{id:"vue-render"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-render"}},[e._v("#")]),e._v(" Vue render")]),e._v(" "),t("p",[e._v("_render 函数的定义位于 "),t("code",[e._v("src/core/instance/render.js")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.prototype._render = function(): VNode {\n  const { render, _parentVnode } = vm.$options\n  vm.$vnode = _parentVnode\n  try {\n    vnode = render.call(vm._renderProxy, vm.$createElement)\n  } catch (e) {\n    handleError(e, vm, `render`)\n  }\n  // set parent\n  vnode.parent = _parentVnode\n  return vnode\n};\n")])])]),t("p",[e._v("vm._render 最终是通过执行 createElement 方法并返回的是 vnode (Virtual DOM)")]),e._v(" "),t("h3",{attrs:{id:"virtual-dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom"}},[e._v("#")]),e._v(" Virtual DOM")]),e._v(" "),t("p",[e._v("真正的 DOM 元素非常庞大，如果频繁的去做 DOM 更新，会产生性能问题。")]),e._v(" "),t("p",[e._v("Virtual DOM 用原生 JS 对象去描述 DOM 节点，比创建 DOM 的代价小很多。Vue 中 Virtual DOM 用 VNode 的 Class 去描述，定义在 "),t("code",[e._v("src/core/vdom/vnode.js")]),e._v(" 中。")]),e._v(" "),t("p",[e._v("VNode 只用来映射到真实 DOM 的渲染，不需要包含操作真正 DOM 的方法。其创建是通过之前提到的 createElement 方法创建的。")]),e._v(" "),t("h3",{attrs:{id:"createelement"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#createelement"}},[e._v("#")]),e._v(" createElement")]),e._v(" "),t("p",[t("code",[e._v("src/core/vdom/create-elemenet.js")])]),e._v(" "),t("p",[e._v("在处理一些参数后")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("return _createElement(context, tag, data, children, normalizationType)\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function _createElement (\n  context, // VNode的上下文环境，Component 类型\n  tag, // 标签，可以是一个字符串或一个 Component\n  data, // Vnode 的子节点，是任意类型的，接下来要被规范为标准 VNode 数组\n  normalizationType // 子节点规范的类型，类型不同规范的方法不同\n  ) {\n  ...\n}\n")])])]),t("h4",{attrs:{id:"children-的规范化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#children-的规范化"}},[e._v("#")]),e._v(" children 的规范化")]),e._v(" "),t("p",[e._v("首先要将 children 规范为 VNode 类型，根据 normalizationType 的不同，调用normalizeChildren(children) 和 simpleNormalizeChildren(children) 方法。")]),e._v(" "),t("p",[t("code",[e._v("src/core/vdom/helpers/normalzie-children.js")])]),e._v(" "),t("p",[e._v("在 render 函数是编译生成时，children 都已经是VNode类型，functional component 会返回一个数组而不是根节点，需要通过 Array.prototype.concat 将 children 数组打平，让它深度只有一层。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nexport function simpleNormalizeChildren (children: any) {\n  for (let i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\nexport function normalizeChildren (children: any): ?Array<VNode> {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n")])])]),t("p",[e._v("normalizeChildren 方法的调用场景有 2 种:")]),e._v(" "),t("ul",[t("li",[e._v("render 函数是用户手写的，当 children 只有一个节点的时候，Vue.js 从接口层面允许用户把 children 写成基础类型用来创建单个简单的文本节点，这种情况会调用 createTextVNode 创建一个文本节点的 VNode。")]),e._v(" "),t("li",[e._v("编译 slot、v-for 的时候会产生嵌套数组的情况，会调用 normalizeArrayChildren 方法。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function normalizeArrayChildren (children: any, nestedIndex?: string): Array<VNode> {\n  const res = []\n  let i, c, lastIndex, last\n  for (i = 0; i < children.length; i++) {\n    c = children[i]\n    if (isUndef(c) || typeof c === 'boolean') continue\n    lastIndex = res.length - 1\n    last = res[lastIndex]\n    //  slot、v-for\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`)\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]: any).text)\n          c.shift()\n        }\n        res.push.apply(res, c)\n      }\n    } else if (isPrimitive(c)) { // 基本数据类型\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c)\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c))\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text)\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = `__vlist${nestedIndex}_${i}__`\n        }\n        res.push(c)\n      }\n    }\n  }\n  return res\n}\n")])])]),t("p",[e._v("经过对 children 的规范化，children 变成了一个类型为 VNode 的 Array。")]),e._v(" "),t("h4",{attrs:{id:"vnode-的创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vnode-的创建"}},[e._v("#")]),e._v(" VNode 的创建")]),e._v(" "),t("p",[t("code",[e._v("createElement")]),e._v(" 函数中，规范了 children 后将会去创建一个 VNode 实例。")]),e._v(" "),t("p",[t("code",[e._v("['普通 VNode', '组件 VNode', '未知类型 VNode']")])]),e._v(" "),t("p",[e._v("当tag是一个 string，判断是否是一个内置节点，如果是则创建一个普通 VNode。否则如果是已注册的组件名则创建一个组件 VNode，否则创建一个未知类型的VNode。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let vnode, ns\nif (typeof tag === 'string') {\n  let Ctor\n  ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)\n  if (config.isReservedTag(tag)) {\n    // platform built-in elements\n    vnode = new VNode(\n      config.parsePlatformTagName(tag), data, children,\n      undefined, undefined, context\n    )\n  } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n    // component\n    vnode = createComponent(Ctor, data, context, children, tag)\n  } else {\n    // unknown or unlisted namespaced elements\n    // check at runtime because it may get assigned a namespace when its\n    // parent normalizes children\n    vnode = new VNode(\n      tag, data, children,\n      undefined, undefined, context\n    )\n  }\n} else {\n  // direct component options / constructor\n  vnode = createComponent(tag, data, context, children)\n}\n")])])]),t("p",[e._v("每个 VNode 有 children，children 每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了 DOM Tree。")]),e._v(" "),t("h3",{attrs:{id:"update"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#update"}},[e._v("#")]),e._v(" update")]),e._v(" "),t("p",[e._v("Vue 的 "),t("code",[e._v("_update")]),e._v(" 是实例的一个私有方法，在首次渲染与数据更新时被调用，作用是把 VNode 渲染为 DOM，定义在 "),t("code",[e._v("src/core/instance/lifecycle.js")]),e._v(" 中。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n  const vm: Component = this\n  const prevEl = vm.$el\n  const prevVnode = vm._vnode\n  const prevActiveInstance = activeInstance\n  activeInstance = vm\n  vm._vnode = vnode\n  // Vue.prototype.__patch__ is injected in entry points\n  // based on the rendering backend used.\n  if (!prevVnode) {\n    // initial render\n    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)\n  } else {\n    // updates\n    vm.$el = vm.__patch__(prevVnode, vnode)\n  }\n  activeInstance = prevActiveInstance\n  // update __vue__ reference\n  if (prevEl) {\n    prevEl.__vue__ = null\n  }\n  if (vm.$el) {\n    vm.$el.__vue__ = vm\n  }\n  // if parent is an HOC, update its $el as well\n  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n    vm.$parent.$el = vm.$el\n  }\n  // updated hook is called by the scheduler to ensure that children are\n  // updated in a parent's updated hook.\n}\n")])])]),t("p",[t("code",[e._v("_update")]),e._v(" 的核心就是调用 "),t("code",[e._v("vm.__patch__")]),e._v(" 方法，这个方法实际上在不同的平台，比如 web 和 weex 上的定义是不一样的，在 web 平台中定义在 src/platforms/web/runtime/index.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.prototype.__patch__ = inBrowser ? patch : noop\n")])])]),t("p",[e._v("patch 方法的定义位于 src/platforms/web/runtime/patch.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import * as nodeOps from 'web/runtime/node-ops'\nimport { createPatchFunction } from 'core/vdom/patch'\nimport baseModules from 'core/vdom/modules/index'\nimport platformModules from 'web/runtime/modules/index'\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nconst modules = platformModules.concat(baseModules)\n\nexport const patch: Function = createPatchFunction({ nodeOps, modules })\n")])])]),t("p",[e._v("createPatchFunction 定义于 "),t("code",[e._v("src/core/vdom/patch.js")])]),e._v(" "),t("p",[e._v("在该方法中定义了一系列辅助方法，最终返回了一个 "),t("code",[e._v("patch")]),e._v(" 方法。patch 是平台相关的，在 web 与 weex 把虚拟 DOM 映射到 平台 DOM 的方法不同。")]),e._v(" "),t("p",[e._v("对应之前的例子：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var app = new Vue({\n  el: '#app',\n  render: function (createElement) {\n    return createElement('div', {\n      attrs: {\n        id: 'app'\n      },\n    }, this.message)\n  },\n  data: {\n    message: 'Hello Vue!'\n  }\n})\n")])])]),t("p",[t("code",[e._v("// initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)")])]),e._v(" "),t("p",[e._v("执行 patch 时传入的 "),t("code",[e._v("vm.$el")]),e._v(" 是 id 为 app 的 DOM 对象，赋值于之前的 mountComponent 函数。"),t("code",[e._v("vnode")]),e._v("对应调用 "),t("code",[e._v("render")]),e._v(" 函数的返回值，其余两个参数为false。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const isRealElement = isDef(oldVnode.nodeType)\nif (!isRealElement && sameVnode(oldVnode, vnode)) {\n  // patch existing root node\n  patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n} else {\n  if (isRealElement) {\n    // mounting to a real element\n    // check if this is server-rendered content and if we can perform\n    // a successful hydration.\n    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n      oldVnode.removeAttribute(SSR_ATTR)\n      hydrating = true\n    }\n    if (isTrue(hydrating)) {\n      if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n        invokeInsertHook(vnode, insertedVnodeQueue, true)\n        return oldVnode\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn(...)\n      }\n    }      \n    // either not server-rendered, or hydration failed.\n    // create an empty node and replace it\n    oldVnode = emptyNodeAt(oldVnode)\n  }\n\n  // replacing existing element\n  const oldElm = oldVnode.elm\n  const parentElm = nodeOps.parentNode(oldElm)\n\n  // create new node\n  createElm(\n    vnode,\n    insertedVnodeQueue,\n    // extremely rare edge case: do not insert if old element is in a\n    // leaving transition. Only happens when combining transition +\n    // keep-alive + HOCs. (#4590)\n    oldElm._leaveCb ? null : parentElm,\n    nodeOps.nextSibling(oldElm)\n  )\n}\n")])])]),t("p",[e._v("传入的 oldVnode 为真实 DOM，通过 emptyNodeAt 方法把 oldVNode 转换为 VNode 对象，再调用 createElm 方法。")]),e._v(" "),t("p",[e._v("createElm: 通过虚拟节点创建真实DOM并插入到父节点。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function createElm (\n  vnode,\n  insertedVnodeQueue,\n  parentElm,\n  refElm,\n  nested,\n  ownerArray,\n  index\n) {\n  if (isDef(vnode.elm) && isDef(ownerArray)) {\n    vnode = ownerArray[index] = cloneVNode(vnode)\n  }\n\n  vnode.isRootInsert = !nested // for transition enter check\n  // 尝试创建子组件\n  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n    return\n  }\n\n  const data = vnode.data\n  const children = vnode.children\n  const tag = vnode.tag\n  // 如果vnode包含tag，先在非生产环境下检验是否是合法标签，再调用平台DOM去创建一个占位元素\n  if (isDef(tag)) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (data && data.pre) {\n        creatingElmInVPre++\n      }\n      if (isUnknownElement(vnode, creatingElmInVPre)) {\n        warn(...)\n      }\n    }\n\n    vnode.elm = vnode.ns\n      ? nodeOps.createElementNS(vnode.ns, tag)\n      : nodeOps.createElement(tag, vnode)\n    setScope(vnode)\n\n    // 创建子元素，遍历子虚拟节点，递归调用createElm\n    /* istanbul ignore if */\n    if (__WEEX__) {\n      // ...\n    } else {\n      createChildren(vnode, children, insertedVnodeQueue)\n      if (isDef(data)) {\n        // 执行create钩子并把 vnode push 到 insertedVnodeQueue\n        invokeCreateHooks(vnode, insertedVnodeQueue)\n      }\n      // 调用insert方法把DOM插入到父节点。子元素优先调用insert，因此整个vnode树节点的插入顺序是先子后父。\n      insert(parentElm, vnode.elm, refElm)\n    }\n\n    if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n      creatingElmInVPre--\n    }\n  } else if (isTrue(vnode.isComment)) {\n    vnode.elm = nodeOps.createComment(vnode.text)\n    insert(parentElm, vnode.elm, refElm)\n  } else {\n    vnode.elm = nodeOps.createTextNode(vnode.text)\n    insert(parentElm, vnode.elm, refElm)\n  }\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function createChildren (vnode, children, insertedVnodeQueue) {\n  if (Array.isArray(children)) {\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(children)\n    }\n    for (let i = 0; i < children.length; ++i) {\n      createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i)\n    }\n  } else if (isPrimitive(vnode.text)) {\n    nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)))\n  }\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function invokeCreateHooks (vnode, insertedVnodeQueue) {\n  for (let i = 0; i < cbs.create.length; ++i) {\n    cbs.create[i](emptyNode, vnode)\n  }\n  i = vnode.data.hook // Reuse variable\n  if (isDef(i)) {\n    if (isDef(i.create)) i.create(emptyNode, vnode)\n    if (isDef(i.insert)) insertedVnodeQueue.push(vnode)\n  }\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function insert (parent, elm, ref) {\n  if (isDef(parent)) {\n    if (isDef(ref)) {\n      if (ref.parentNode === parent) {\n        nodeOps.insertBefore(parent, elm, ref)\n      }\n    } else {\n      nodeOps.appendChild(parent, elm)\n    }\n  }\n}\n")])])]),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("Vue的渲染过程: new->init->$mount->complie(如果写template)->render->vnode->patch->DOM")])])}),[],!1,null,null,null);n.default=a.exports}}]);