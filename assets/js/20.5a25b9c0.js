(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{230:function(e,n,t){"use strict";t.r(n);var o=t(1),a=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"组件化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件化"}},[e._v("#")]),e._v(" 组件化")]),e._v(" "),t("p",[e._v("组件化，就是把页面拆分为多个组件，组件是资源独立的，组件在系统内可复用，组件和组件之间可以嵌套。")]),e._v(" "),t("h2",{attrs:{id:"createcomponent"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#createcomponent"}},[e._v("#")]),e._v(" createComponent")]),e._v(" "),t("p",[t("code",[e._v("createElement")]),e._v(" 最终会调用 "),t("code",[e._v("_createElement")]),e._v(" 方法，其中有一段对 "),t("code",[e._v("tag")]),e._v(" 的判断，如果是一个 string，会实例化为一个普通 VNode 节点或未知类型节点，否则通过 "),t("code",[e._v("createComponent")]),e._v(" 方法创建一个组件 VNode。")]),e._v(" "),t("p",[e._v("传入的是一个App对象时，直接通过 createComponent 方法创建 vnode。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function createComponent (\n  Ctor: Class<Component> | Function | Object | void,\n  data: ?VNodeData,\n  context: Component,\n  children: ?Array<VNode>,\n  tag?: string\n): VNode | Array<VNode> | void {}\n")])])]),t("p",[t("code",[e._v("src/core/vdom/create-component.js")]),e._v(" 中主要有以下三个步骤：")]),e._v(" "),t("h3",{attrs:{id:"构造子类构造函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造子类构造函数"}},[e._v("#")]),e._v(" 构造子类构造函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const baseCtor = context.$options._base\n\n// plain options object: turn it into a constructor\nif (isObject(Ctor)) {\n  Ctor = baseCtor.extend(Ctor)\n}\n\nimport HelloWorld from './components/HelloWorld'\n\nexport default {\n  name: 'app',\n  components: {\n    HelloWorld\n  }\n}\n")])])]),t("p",[e._v("这里export了一个对象，createComponent 中就会执行到 baseCtor.extend(Ctor)，baseCtor就是 Vue，这是 "),t("code",[e._v("src/core/global-api/index.js")]),e._v(" 中 initGlobalAPI 函数的逻辑：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.options._base = Vue\n")])])]),t("p",[e._v("这里定义了options，之前的 createComponent 取自 context.$options，在 "),t("code",[e._v("src/core/instance/init.js")]),e._v(" 原型上的 _init 函数中有相关逻辑:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vm.$options = mergeOptions(\n  resolveConstructorOptions(vm.constructor),\n  options || {},\n  vm\n)\n")])])]),t("p",[t("strong",[t("code",[e._v("Vue.extend")]),e._v(" 的定义")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue.extend = function (extendOptions: Object): Function {\n  extendOptions = extendOptions || {}\n  const Super = this\n  const SuperId = Super.cid\n  const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})\n  if (cachedCtors[SuperId]) {\n    return cachedCtors[SuperId]\n  }\n\n  const name = extendOptions.name || Super.options.name\n  if (process.env.NODE_ENV !== 'production' && name) {\n    validateComponentName(name)\n  }\n\n  const Sub = function VueComponent (options) {\n    this._init(options)\n  }\n  Sub.prototype = Object.create(Super.prototype)\n  Sub.prototype.constructor = Sub\n  Sub.options = mergeOptions(\n    Super.options,\n    extendOptions\n  )\n  Sub['super'] = Super\n  ...\n  // cache constructor\n  cachedCtors[SuperId] = Sub\n  return Sub\n}\n")])])]),t("p",[e._v("将一个纯对象转化为一个基于 Vue 的构造器 Sub 并返回，并对其进行拓展，最后将该构造器针对其Id进行缓存避免重复构造。")]),e._v(" "),t("h3",{attrs:{id:"安装组件钩子函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装组件钩子函数"}},[e._v("#")]),e._v(" 安装组件钩子函数")]),e._v(" "),t("p",[e._v("Vue的vdom参考了开源库snabbdom，它的特点是在patch流程中对外暴露了各种时机的钩子函数。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("installComponentHooks(data)\n")])])]),t("p",[t("code",[e._v("src/core/vdom/create-component.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const componentVNodeHooks = {\n  init (vnode: VNodeWithData, hydrating: boolean): ?boolean {}\n  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {}\n  insert (vnode: MountedComponentVNode) {}\n  destroy (vnode: MountedComponentVNode) {}\n}\n\nconst hooksToMerge = Object.keys(componentVNodeHooks)\n\nfunction installComponentHooks (data: VNodeData) {\n  const hooks = data.hook || (data.hook = {})\n  for (let i = 0; i < hooksToMerge.length; i++) {\n    const key = hooksToMerge[i]\n    const existing = hooks[key]\n    const toMerge = componentVNodeHooks[key]\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge\n    }\n  }\n}\n")])])]),t("p",[t("code",[e._v("installComponentHooks")]),e._v(" 就是将 "),t("code",[e._v("componentVNodeHooks")]),e._v(" 的钩子函数合并到 data.hook 中，在 VNode 执行 patch 的过程中执行相关钩子函数，合并时如果某个时机的钩子已经存在 "),t("code",[e._v("data.hook")]),e._v(" 中，那么通过 "),t("code",[e._v("mergeHook")]),e._v(" 做合并。")]),e._v(" "),t("h3",{attrs:{id:"实例化vnode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实例化vnode"}},[e._v("#")]),e._v(" 实例化VNode")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const name = Ctor.options.name || tag\nconst vnode = new VNode(\n  `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,\n  data, undefined, undefined, undefined, context,\n  { Ctor, propsData, listeners, tag, children },\n  asyncFactory\n)\nreturn vnode\n")])])]),t("p",[e._v("通过 new VNode实例化一个 vnode 并返回。与普通元素节点的 vnode 不同，组件的 vnode 是没有 children 的。")]),e._v(" "),t("p",[e._v("createComponent 会返回 vnode，同样会执行 "),t("code",[e._v("vm._update")]),e._v(" 方法，进而执行 "),t("code",[e._v("patch")]),e._v(" 函数。")]),e._v(" "),t("h2",{attrs:{id:"patch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#patch"}},[e._v("#")]),e._v(" patch")]),e._v(" "),t("p",[e._v("patch 的过程会调用 createElm 创建元素节点，定义在 "),t("code",[e._v("src/core/vdom/patch.js")]),e._v(" 中")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function createElm (\n  vnode,\n  insertedVnodeQueue,\n  parentElm,\n  refElm,\n  nested,\n  ownerArray,\n  index\n) {\n  // 这里又会出现一个 createComponent\n  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n    return\n  }\n  // ...\n}\n")])])]),t("h3",{attrs:{id:"createcomponent-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#createcomponent-2"}},[e._v("#")]),e._v(" createComponent")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n  let i = vnode.data\n  if (isDef(i)) {\n    const isReactivated = isDef(vnode.componentInstance) && i.keepAlive\n    if (isDef(i = i.hook) && isDef(i = i.init)) {\n      i(vnode, false /* hydrating */)\n    }\n    // after calling the init hook, if the vnode is a child component\n    // it should've created a child instance and mounted it. the child\n    // component also has set the placeholder vnode's elm.\n    // in that case we can just return the element and be done.\n    if (isDef(vnode.componentInstance)) {\n      initComponent(vnode, insertedVnodeQueue)\n      insert(parentElm, vnode.elm, refElm)\n      if (isTrue(isReactivated)) {\n        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)\n      }\n      return true\n    }\n  }\n}\n")])])]),t("p",[e._v("首先对 "),t("code",[e._v("vnode.data")]),e._v(" 做判断，如果 vnode 是一个 VNode，则得到 i 是钩子函数。在创建组件 VNode 时合并的钩子函数中包含 init 钩子函数。（上一章介绍过）\n该函数通过 "),t("code",[e._v("createComponentInstanceForVnode")]),e._v(" 创建一个 Vue 的实例，然后调用 "),t("code",[e._v("$mount")]),e._v(" 方法挂载子组件。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function createComponentInstanceForVnode (\n  vnode: any, // we know it's MountedComponentVNode but flow doesn't\n  parent: any, // activeInstance in lifecycle state\n): Component {\n  const options: InternalComponentOptions = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent\n  }\n  // check inline-template render functions\n  const inlineTemplate = vnode.data.inlineTemplate\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render\n    options.staticRenderFns = inlineTemplate.staticRenderFns\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n")])])]),t("p",[e._v("这里的 "),t("code",[e._v("new vnode.componentOptions.Ctor(options)")]),e._v(" 相当于上节的 "),t("code",[e._v("new Sub(options)")])])])}),[],!1,null,null,null);n.default=a.exports}}]);